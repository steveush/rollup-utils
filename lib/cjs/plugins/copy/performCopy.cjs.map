{"version":3,"file":"performCopy.cjs","sources":["../../../../src/plugins/copy/performCopy.js"],"sourcesContent":["import toShortTime from \"../../utils/internal/toShortTime.js\";\r\nimport { globby } from \"globby\";\r\nimport { dirname, join } from \"path\";\r\nimport { copyFile, mkdir } from \"fs/promises\";\r\nimport isString from \"../../utils/internal/isString.js\";\r\nimport isArray from \"../../utils/internal/isArray.js\";\r\n\r\n/**\r\n * Performs the copying of files from one path to another.\r\n *\r\n * @param {import('rollup').PluginContext} ctx - The current Rollup plugin context.\r\n * @param {string} source - The directory to copy files from.\r\n * @param {string} target - The directory to copy files to.\r\n * @param {string[]} [patterns] - Optional. A string array of {@link https://github.com/sindresorhus/globby?tab=readme-ov-file#globbypatterns-options|globby patterns} used to match the files to copy. Defaults to all files.\r\n * @returns {Promise<void>}\r\n * @remarks Additional information is output via the `ctx.debug`, `ctx.error` and `ctx.warn` methods.\r\n */\r\nconst performCopy = async( ctx, source, target, patterns = [ \"**/*\" ] ) => {\r\n    if ( !isString( source, true ) || !isString( target, true ) ) {\r\n        ctx.warn( 'No files copied as either the \"from\" or \"to\" paths were empty or not strings.' );\r\n        return;\r\n    }\r\n\r\n    if ( !isArray( patterns, true, p => isString( p, true ) ) ) {\r\n        ctx.warn( 'No files copied as the \"patterns\" array was empty or contained values other than strings.' );\r\n        return;\r\n    }\r\n\r\n    try {\r\n        const started = Date.now();\r\n        ctx.debug( `copying ${ source } to ${ target }...` );\r\n\r\n        const found = await globby( patterns, { cwd: source } );\r\n        await Promise.all( found.map( file => {\r\n            const output = join( target, file );\r\n            return mkdir( dirname( output ), { recursive: true } )\r\n                .then( () => copyFile( join( source, file ), output ) );\r\n        } ) );\r\n        ctx.debug( `copied ${ source } in ${ toShortTime( Date.now() - started ) }` );\r\n    } catch ( err ) {\r\n        ctx.error( `copy error: ${ err.message }` );\r\n    }\r\n};\r\n\r\nexport default performCopy;"],"names":["performCopy","ctx","source","target","patterns","arguments","length","undefined","isString","warn","isArray","p","started","Date","now","debug","found","globby","cwd","Promise","all","map","file","output","join","mkdir","dirname","recursive","then","copyFile","toShortTime","err","error","message"],"mappings":";;;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACMA,MAAAA,WAAW,GAAG,gBAAOC,GAAG,EAAEC,MAAM,EAAEC,MAAM,EAA6B;AAAA,EAAA,IAA3BC,QAAQ,GAAAC,SAAA,CAAAC,MAAA,GAAAD,CAAAA,IAAAA,SAAA,CAAAE,CAAAA,CAAAA,KAAAA,SAAA,GAAAF,SAAA,CAAG,CAAA,CAAA,GAAA,CAAE,MAAM,CAAE,CAAA;AACjE,EAAA,IAAK,CAACG,QAAQ,CAAEN,MAAM,EAAE,IAAK,CAAC,IAAI,CAACM,QAAQ,CAAEL,MAAM,EAAE,IAAK,CAAC,EAAG;AAC1DF,IAAAA,GAAG,CAACQ,IAAI,CAAE,+EAAgF,CAAC,CAAA;AAC3F,IAAA,OAAA;AACJ,GAAA;AAEA,EAAA,IAAK,CAACC,OAAO,CAAEN,QAAQ,EAAE,IAAI,EAAEO,CAAC,IAAIH,QAAQ,CAAEG,CAAC,EAAE,IAAK,CAAE,CAAC,EAAG;AACxDV,IAAAA,GAAG,CAACQ,IAAI,CAAE,2FAA4F,CAAC,CAAA;AACvG,IAAA,OAAA;AACJ,GAAA;EAEA,IAAI;AACA,IAAA,MAAMG,OAAO,GAAGC,IAAI,CAACC,GAAG,EAAE,CAAA;IAC1Bb,GAAG,CAACc,KAAK,CAAG,CAAA,QAAA,EAAWb,MAAQ,CAAOC,IAAAA,EAAAA,MAAQ,KAAK,CAAC,CAAA;AAEpD,IAAA,MAAMa,KAAK,GAAG,MAAMC,aAAM,CAAEb,QAAQ,EAAE;AAAEc,MAAAA,GAAG,EAAEhB,MAAAA;AAAO,KAAE,CAAC,CAAA;IACvD,MAAMiB,OAAO,CAACC,GAAG,CAAEJ,KAAK,CAACK,GAAG,CAAEC,IAAI,IAAI;AAClC,MAAA,MAAMC,MAAM,GAAGC,SAAI,CAAErB,MAAM,EAAEmB,IAAK,CAAC,CAAA;AACnC,MAAA,OAAOG,cAAK,CAAEC,YAAO,CAAEH,MAAO,CAAC,EAAE;AAAEI,QAAAA,SAAS,EAAE,IAAA;AAAK,OAAE,CAAC,CACjDC,IAAI,CAAE,MAAMC,iBAAQ,CAAEL,SAAI,CAAEtB,MAAM,EAAEoB,IAAK,CAAC,EAAEC,MAAO,CAAE,CAAC,CAAA;AAC/D,KAAE,CAAE,CAAC,CAAA;AACLtB,IAAAA,GAAG,CAACc,KAAK,CAAG,CAAUb,OAAAA,EAAAA,MAAQ,OAAO4B,WAAW,CAAEjB,IAAI,CAACC,GAAG,EAAE,GAAGF,OAAQ,CAAG,EAAE,CAAC,CAAA;GAChF,CAAC,OAAQmB,GAAG,EAAG;IACZ9B,GAAG,CAAC+B,KAAK,CAAG,CAAA,YAAA,EAAeD,GAAG,CAACE,OAAS,EAAE,CAAC,CAAA;AAC/C,GAAA;AACJ;;;;"}